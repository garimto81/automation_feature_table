# PRD-0011 Checklist: GFX PC → Supabase 직접 동기화

## 문서 정보

| 항목 | 내용 |
|------|------|
| **PRD** | [PRD-0011](../../tasks/prds/PRD-0011-gfx-direct-supabase-sync.md) |
| **생성일** | 2026-01-12 |
| **상태** | 🟢 Phase 1-4 완료 |
| **진행률** | 78% (23/30) |

---

## 개발 TODO

### Phase 1: LocalQueue (SQLite 오프라인 큐) ✅

| 순서 | 항목 | 상태 | PR |
|:----:|------|:----:|:--:|
| 1-1 | `LocalQueue` 클래스 테스트 작성 | ✅ | 35068a2 |
| 1-2 | `LocalQueue._init_db()` 구현 | ✅ | 35068a2 |
| 1-3 | `LocalQueue.enqueue()` 구현 | ✅ | 35068a2 |
| 1-4 | `LocalQueue.get_pending()` 구현 | ✅ | 35068a2 |
| 1-5 | `LocalQueue.mark_completed()` 구현 | ✅ | 35068a2 |
| 1-6 | `LocalQueue.increment_retry()` 구현 | ✅ | 35068a2 |

### Phase 2: SyncService (Supabase 동기화) ✅

| 순서 | 항목 | 상태 | PR |
|:----:|------|:----:|:--:|
| 2-1 | `SyncService` 클래스 테스트 작성 | ✅ | 35068a2 |
| 2-2 | `SyncService.__init__()` 구현 | ✅ | 35068a2 |
| 2-3 | `SyncService._compute_hash()` 구현 | ✅ | 35068a2 |
| 2-4 | `SyncService._is_duplicate()` 구현 | ✅ | 35068a2 |
| 2-5 | `SyncService.sync_file()` 구현 | ✅ | 35068a2 |
| 2-6 | `SyncService.process_offline_queue()` 구현 | ✅ | 35068a2 |

### Phase 3: GFXFileHandler (파일 감시) ✅

| 순서 | 항목 | 상태 | PR |
|:----:|------|:----:|:--:|
| 3-1 | `GFXFileHandler` 클래스 테스트 작성 | ✅ | 35068a2 |
| 3-2 | `GFXFileHandler._matches_pattern()` 구현 | ✅ | 35068a2 |
| 3-3 | `GFXFileHandler.on_created()` 구현 | ✅ | 35068a2 |
| 3-4 | `GFXFileHandler.on_modified()` 구현 | ✅ | 35068a2 |
| 3-5 | `GFXFileHandler._schedule_sync()` 디바운스 구현 | ✅ | 35068a2 |

### Phase 4: 설정 및 메인 스크립트 ✅

| 순서 | 항목 | 상태 | PR |
|:----:|------|:----:|:--:|
| 4-1 | `SyncAgentSettings` Pydantic 모델 구현 | ✅ | 35068a2 |
| 4-2 | `config.env.example` 템플릿 작성 | ⬜ | - |
| 4-3 | `sync_agent.py` 메인 스크립트 구현 | ⬜ | - |
| 4-4 | 로깅 설정 (파일 + 콘솔) | ✅ | 35068a2 |
| 4-5 | 헬스체크 기능 | ✅ | 35068a2 |

### Phase 5: 스키마 및 배포

| 순서 | 항목 | 상태 | PR |
|:----:|------|:----:|:--:|
| 5-1 | Supabase `sync_source` 컬럼 추가 | ⬜ | - |
| 5-2 | 통합 테스트 작성 | ⬜ | - |
| 5-3 | `requirements.txt` 작성 | ⬜ | - |
| 5-4 | `install.ps1` 설치 스크립트 | ⬜ | - |
| 5-5 | PyInstaller 빌드 테스트 | ⬜ | - |
| 5-6 | Windows 서비스 등록 스크립트 | ⬜ | - |

---

## 테스트 현황

| 테스트 파일 | 테스트 수 | 상태 |
|------------|:--------:|:----:|
| `test_local_queue.py` | 19 | ✅ |
| `test_sync_service.py` | 10 | ✅ |
| `test_file_handler.py` | 10 | ✅ |
| `test_config.py` | 7 | ✅ |
| **전체** | **47** | ✅ |

---

## TDD 설계

### 1. LocalQueue 테스트 (`tests/sync_agent/test_local_queue.py`)

```python
"""LocalQueue TDD 테스트 케이스"""
import pytest
from pathlib import Path

class TestLocalQueue:
    """SQLite 기반 오프라인 큐 테스트"""

    # === Red Phase: 실패하는 테스트 먼저 작성 ===

    def test_init_creates_db_file(self, tmp_path):
        """DB 파일 생성 확인"""
        db_path = tmp_path / "test.db"
        queue = LocalQueue(str(db_path))
        assert db_path.exists()

    def test_init_creates_table(self, tmp_path):
        """pending_syncs 테이블 생성 확인"""
        db_path = tmp_path / "test.db"
        queue = LocalQueue(str(db_path))
        assert queue._table_exists("pending_syncs")

    def test_enqueue_adds_item(self, tmp_path):
        """큐에 항목 추가"""
        queue = LocalQueue(str(tmp_path / "test.db"))
        queue.enqueue("/path/to/file.json", "created")
        pending = queue.get_pending()
        assert len(pending) == 1
        assert pending[0]["file_path"] == "/path/to/file.json"
        assert pending[0]["operation"] == "created"
        assert pending[0]["status"] == "pending"

    def test_get_pending_respects_limit(self, tmp_path):
        """get_pending limit 파라미터 동작"""
        queue = LocalQueue(str(tmp_path / "test.db"))
        for i in range(10):
            queue.enqueue(f"/file_{i}.json", "created")
        pending = queue.get_pending(limit=5)
        assert len(pending) == 5

    def test_get_pending_orders_by_created_at(self, tmp_path):
        """FIFO 순서 확인"""
        queue = LocalQueue(str(tmp_path / "test.db"))
        queue.enqueue("/first.json", "created")
        queue.enqueue("/second.json", "created")
        pending = queue.get_pending()
        assert pending[0]["file_path"] == "/first.json"
        assert pending[1]["file_path"] == "/second.json"

    def test_mark_completed_changes_status(self, tmp_path):
        """완료 표시 후 get_pending에서 제외"""
        queue = LocalQueue(str(tmp_path / "test.db"))
        queue.enqueue("/file.json", "created")
        pending = queue.get_pending()
        queue.mark_completed(pending[0]["id"])
        assert len(queue.get_pending()) == 0

    def test_increment_retry_updates_count(self, tmp_path):
        """재시도 카운트 증가"""
        queue = LocalQueue(str(tmp_path / "test.db"))
        queue.enqueue("/file.json", "created")
        pending = queue.get_pending()
        item_id = pending[0]["id"]
        queue.increment_retry(item_id)
        updated = queue.get_pending()
        assert updated[0]["retry_count"] == 1

    def test_get_pending_excludes_max_retries(self, tmp_path):
        """최대 재시도 초과 항목 제외"""
        queue = LocalQueue(str(tmp_path / "test.db"), max_retries=3)
        queue.enqueue("/file.json", "created")
        pending = queue.get_pending()
        for _ in range(3):
            queue.increment_retry(pending[0]["id"])
        assert len(queue.get_pending()) == 0
```

### 2. SyncService 테스트 (`tests/sync_agent/test_sync_service.py`)

```python
"""SyncService TDD 테스트 케이스"""
import json
import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from pathlib import Path

class TestSyncService:
    """Supabase 동기화 서비스 테스트"""

    @pytest.fixture
    def sample_gfx_json(self, tmp_path) -> Path:
        """샘플 GFX JSON 파일 생성"""
        data = {
            "ID": "game_123",
            "Type": "Tournament",
            "EventTitle": "WSOP Main Event",
            "SoftwareVersion": "3.0.1",
            "CreatedDateTimeUTC": "2026-01-12T10:00:00Z",
            "Hands": [
                {"HandNumber": 1, "Cards": ["Ah", "Kh"]},
                {"HandNumber": 2, "Cards": ["Qd", "Jd"]},
            ]
        }
        file_path = tmp_path / "PGFX_live_data_export GameID=123.json"
        file_path.write_text(json.dumps(data))
        return file_path

    @pytest.fixture
    def mock_supabase(self):
        """Supabase 클라이언트 Mock"""
        with patch("src.sync_agent.sync_service.create_client") as mock:
            client = MagicMock()
            mock.return_value = client
            yield client

    def test_compute_hash_returns_sha256(self, sample_gfx_json):
        """SHA256 해시 계산"""
        service = SyncService("url", "key")
        hash_value = service._compute_hash(sample_gfx_json)
        assert len(hash_value) == 64  # SHA256 hex length
        assert hash_value.isalnum()

    def test_compute_hash_same_content_same_hash(self, tmp_path):
        """동일 내용 = 동일 해시"""
        content = b'{"test": "data"}'
        file1 = tmp_path / "file1.json"
        file2 = tmp_path / "file2.json"
        file1.write_bytes(content)
        file2.write_bytes(content)

        service = SyncService("url", "key")
        assert service._compute_hash(file1) == service._compute_hash(file2)

    async def test_is_duplicate_returns_true_for_existing(self, mock_supabase):
        """이미 존재하는 해시 → True"""
        mock_supabase.table().select().eq().limit().execute.return_value = (
            MagicMock(data=[{"id": 1}])
        )
        service = SyncService("url", "key")
        result = await service._is_duplicate("existing_hash")
        assert result is True

    async def test_is_duplicate_returns_false_for_new(self, mock_supabase):
        """새 해시 → False"""
        mock_supabase.table().select().eq().limit().execute.return_value = (
            MagicMock(data=[])
        )
        service = SyncService("url", "key")
        result = await service._is_duplicate("new_hash")
        assert result is False

    async def test_sync_file_uploads_to_supabase(
        self, sample_gfx_json, mock_supabase
    ):
        """파일 업로드 성공"""
        mock_supabase.table().select().eq().limit().execute.return_value = (
            MagicMock(data=[])
        )
        mock_supabase.table().upsert().execute.return_value = MagicMock()

        service = SyncService("url", "key")
        result = await service.sync_file(str(sample_gfx_json), "created")

        assert result is True
        mock_supabase.table().upsert.assert_called_once()

    async def test_sync_file_skips_duplicate(
        self, sample_gfx_json, mock_supabase
    ):
        """중복 파일 스킵"""
        mock_supabase.table().select().eq().limit().execute.return_value = (
            MagicMock(data=[{"id": 1}])
        )

        service = SyncService("url", "key")
        result = await service.sync_file(str(sample_gfx_json), "created")

        assert result is True
        mock_supabase.table().upsert.assert_not_called()

    async def test_sync_file_queues_on_connection_error(
        self, sample_gfx_json, mock_supabase
    ):
        """연결 오류 시 로컬 큐에 저장"""
        mock_supabase.table().select().eq().limit().execute.side_effect = (
            ConnectionError("Network error")
        )

        service = SyncService("url", "key")
        service.local_queue = MagicMock()
        result = await service.sync_file(str(sample_gfx_json), "created")

        assert result is False
        service.local_queue.enqueue.assert_called_once()

    async def test_sync_file_extracts_correct_metadata(
        self, sample_gfx_json, mock_supabase
    ):
        """메타데이터 추출 검증"""
        mock_supabase.table().select().eq().limit().execute.return_value = (
            MagicMock(data=[])
        )
        captured_record = {}

        def capture_upsert(record, **kwargs):
            captured_record.update(record)
            return MagicMock(execute=MagicMock())

        mock_supabase.table().upsert = capture_upsert

        service = SyncService("url", "key")
        await service.sync_file(str(sample_gfx_json), "created")

        assert captured_record["session_id"] == "game_123"
        assert captured_record["table_type"] == "Tournament"
        assert captured_record["hand_count"] == 2
        assert captured_record["sync_source"] == "gfx_pc_direct"

    async def test_process_offline_queue_retries_pending(self, mock_supabase, tmp_path):
        """오프라인 큐 재시도"""
        service = SyncService("url", "key")
        service.local_queue = MagicMock()
        service.local_queue.get_pending.return_value = [
            {"id": 1, "file_path": "/test.json", "operation": "created"}
        ]
        service.sync_file = AsyncMock(return_value=True)

        await service.process_offline_queue()

        service.local_queue.mark_completed.assert_called_with(1)
```

### 3. GFXFileHandler 테스트 (`tests/sync_agent/test_file_handler.py`)

```python
"""GFXFileHandler TDD 테스트 케이스"""
import asyncio
import pytest
from unittest.mock import MagicMock, AsyncMock
from watchdog.events import FileCreatedEvent, FileModifiedEvent

class TestGFXFileHandler:
    """파일 감시 핸들러 테스트"""

    def test_matches_pattern_valid_filename(self):
        """유효한 GFX 파일명 매칭"""
        handler = GFXFileHandler(MagicMock())
        assert handler._matches_pattern(
            "C:/GFX/output/PGFX_live_data_export GameID=123.json"
        ) is True

    def test_matches_pattern_invalid_filename(self):
        """무효한 파일명 거부"""
        handler = GFXFileHandler(MagicMock())
        assert handler._matches_pattern("C:/GFX/output/other_file.json") is False
        assert handler._matches_pattern("C:/GFX/output/readme.txt") is False

    def test_on_created_triggers_sync_for_valid_file(self):
        """파일 생성 시 동기화 트리거"""
        sync_service = MagicMock()
        handler = GFXFileHandler(sync_service)

        event = FileCreatedEvent(
            "C:/GFX/output/PGFX_live_data_export GameID=456.json"
        )
        handler.on_created(event)

        assert handler._pending.get(event.src_path) is not None

    def test_on_created_ignores_directories(self):
        """디렉토리 이벤트 무시"""
        sync_service = MagicMock()
        handler = GFXFileHandler(sync_service)

        event = MagicMock(is_directory=True, src_path="C:/GFX/output/subdir")
        handler.on_created(event)

        assert len(handler._pending) == 0

    def test_on_modified_triggers_sync(self):
        """파일 수정 시 동기화 트리거"""
        sync_service = MagicMock()
        handler = GFXFileHandler(sync_service)

        event = FileModifiedEvent(
            "C:/GFX/output/PGFX_live_data_export GameID=789.json"
        )
        handler.on_modified(event)

        assert handler._pending.get(event.src_path) is not None

    async def test_schedule_sync_debounces_rapid_events(self):
        """빠른 연속 이벤트 디바운스"""
        sync_service = MagicMock()
        sync_service.sync_file = AsyncMock()
        handler = GFXFileHandler(sync_service, settle_delay=0.1)

        path = "C:/GFX/output/PGFX_live_data_export GameID=999.json"

        for _ in range(5):
            handler._schedule_sync(path, "modified")

        await asyncio.sleep(0.2)

        # 마지막 1번만 실행
        sync_service.sync_file.assert_called_once_with(path, "modified")

    def test_on_created_ignores_non_matching_files(self):
        """패턴 불일치 파일 무시"""
        sync_service = MagicMock()
        handler = GFXFileHandler(sync_service)

        event = FileCreatedEvent("C:/GFX/output/config.json")
        handler.on_created(event)

        assert len(handler._pending) == 0
```

### 4. 통합 테스트 (`tests/sync_agent/test_integration.py`)

```python
"""통합 테스트"""
import asyncio
import json
import pytest
from unittest.mock import MagicMock, patch
from watchdog.observers import Observer

class TestIntegration:
    """End-to-end 통합 테스트"""

    @pytest.fixture
    def mock_supabase_env(self, monkeypatch):
        """환경 변수 Mock"""
        monkeypatch.setenv("SUPABASE_URL", "https://test.supabase.co")
        monkeypatch.setenv("SUPABASE_KEY", "test_key")

    async def test_file_created_to_upload_flow(
        self, tmp_path, mock_supabase_env
    ):
        """파일 생성 → Supabase 업로드 전체 흐름"""
        with patch("src.sync_agent.sync_service.create_client") as mock:
            mock_client = MagicMock()
            mock.return_value = mock_client
            mock_client.table().select().eq().limit().execute.return_value = (
                MagicMock(data=[])
            )

            watch_dir = tmp_path / "output"
            watch_dir.mkdir()

            sync_service = SyncService("url", "key")
            handler = GFXFileHandler(sync_service, settle_delay=0.1)

            observer = Observer()
            observer.schedule(handler, str(watch_dir), recursive=False)
            observer.start()

            try:
                test_file = watch_dir / "PGFX_live_data_export GameID=test.json"
                test_file.write_text(json.dumps({
                    "ID": "test",
                    "Type": "Cash",
                    "Hands": []
                }))

                await asyncio.sleep(0.3)

                mock_client.table().upsert.assert_called()
            finally:
                observer.stop()
                observer.join()

    async def test_offline_queue_recovery(self, tmp_path):
        """오프라인 → 온라인 복구 테스트"""
        with patch("src.sync_agent.sync_service.create_client") as mock:
            mock_client = MagicMock()
            mock.return_value = mock_client

            # 1. 오프라인 상태에서 큐잉
            mock_client.table().select().eq().limit().execute.side_effect = (
                ConnectionError("Offline")
            )

            queue = LocalQueue(str(tmp_path / "queue.db"))
            service = SyncService("url", "key")
            service.local_queue = queue

            test_file = tmp_path / "PGFX_live_data_export GameID=offline.json"
            test_file.write_text(json.dumps({"ID": "offline", "Hands": []}))

            await service.sync_file(str(test_file), "created")
            assert len(queue.get_pending()) == 1

            # 2. 온라인 복구
            mock_client.table().select().eq().limit().execute.side_effect = None
            mock_client.table().select().eq().limit().execute.return_value = (
                MagicMock(data=[])
            )

            await service.process_offline_queue()
            assert len(queue.get_pending()) == 0
```

---

## 파일 구조

```
src/sync_agent/
├── __init__.py
├── config.py              # SyncAgentSettings
├── local_queue.py         # LocalQueue 클래스
├── sync_service.py        # SyncService 클래스
├── file_handler.py        # GFXFileHandler 클래스
└── main.py                # 메인 엔트리포인트

tests/sync_agent/
├── __init__.py
├── conftest.py            # 공통 Fixtures
├── test_local_queue.py
├── test_sync_service.py
├── test_file_handler.py
└── test_integration.py
```

---

## 의존성

```txt
# requirements.txt (sync_agent 전용)
supabase>=2.0.0
watchdog>=3.0.0
python-dotenv>=1.0.0
pydantic-settings>=2.0.0
```

---

## 비기능 요구사항 검증

| ID | 요구사항 | 테스트 방법 |
|----|----------|-------------|
| NFR-01 | 파일 감지 → 업로드 < 5초 | `test_file_created_to_upload_flow` 타이밍 측정 |
| NFR-02 | 메모리 < 50MB | 프로파일링 (`memory_profiler`) |
| NFR-03 | CPU (대기) < 1% | `psutil` 모니터링 |
| NFR-04 | 오프라인 큐 용량 1000 | `test_queue_capacity_1000` |
| NFR-05 | 지수 백오프 재시도 | `test_exponential_backoff` |

---

## 진행 상황

| 날짜 | 작업 | 결과 | 담당 |
|------|------|------|------|
| 2026-01-12 | PRD-0011 작성 | ✅ 완료 | Claude |
| 2026-01-12 | 개발 TODO/TDD 설계 | ✅ 완료 | Claude |
| - | Phase 1: LocalQueue 구현 | ⏳ 대기 | - |
| - | Phase 2: SyncService 구현 | ⏳ 대기 | - |
| - | Phase 3: GFXFileHandler 구현 | ⏳ 대기 | - |
| - | Phase 4: 메인 스크립트 | ⏳ 대기 | - |
| - | Phase 5: 통합/배포 | ⏳ 대기 | - |

---

## 변경 이력

| 날짜 | 변경 내용 |
|------|----------|
| 2026-01-12 | 초안 작성 |
| 2026-01-12 | TDD 설계 및 상세 TODO 추가 |
